<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jarvis</title>
  
  <subtitle>是谁说过：时间仍在，是我们在飞逝</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-06-05T12:09:03.493Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Jellyleo</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>常用SQL语句</title>
    <link href="http://yoursite.com/2018/06/05/%E5%B8%B8%E7%94%A8SQL%E8%AF%AD%E5%8F%A5/"/>
    <id>http://yoursite.com/2018/06/05/常用SQL语句/</id>
    <published>2018-06-05T10:51:11.000Z</published>
    <updated>2018-06-05T12:09:03.493Z</updated>
    
    <content type="html"><![CDATA[<h2 id="SQL-DML-和-DDL"><a href="#SQL-DML-和-DDL" class="headerlink" title="SQL DML 和 DDL"></a>SQL DML 和 DDL</h2><p>可以把 SQL 分为两个部分：数据操作语言 (DML) 和 数据定义语言 (DDL)。<br>SQL (结构化查询语言)是用于执行查询的语法。但是 SQL 语言也包含用于更新、插入和删除记录的语法。</p><p>查询和更新指令构成了 SQL 的 DML 部分：</p><ul><li>SELECT - 从数据库表中获取数据</li><li>UPDATE - 更新数据库表中的数据</li><li>DELETE - 从数据库表中删除数据</li><li>INSERT INTO - 向数据库表中插入数据</li></ul><p>SQL 的数据定义语言 (DDL) 部分使我们有能力创建或删除表格。我们也可以定义索引（键），规定表之间的链接，以及施加表间的约束。</p><p>SQL 中最重要的 DDL 语句:</p><ul><li>CREATE DATABASE - 创建新数据库</li><li>ALTER DATABASE - 修改数据库</li><li>CREATE TABLE - 创建新表</li><li>ALTER TABLE - 变更（改变）数据库表</li><li>DROP TABLE - 删除表</li><li>CREATE INDEX - 创建索引（搜索键）</li><li>DROP INDEX - 删除索引</li></ul><h2 id="常用查询语句"><a href="#常用查询语句" class="headerlink" title="常用查询语句"></a>常用查询语句</h2><p>单表查询</p><pre><code>select * from 表名;</code></pre><p>查询指定字段</p><pre><code>select 字段1，字段2，字段3....from 表名;</code></pre><p>where条件查询 : select 字段1，字段2，字段3 from 表名 where 条件表达式;</p><pre><code>select * from studect where id=1;select * from student where age&gt;22;</code></pre><p>in关键字查询 : select 字段1，字段2 frome 表名 where 字段 [not] in(元素1，元素2);</p><pre><code>select * from student where age in (21,23);select * from student where age not in (21,23);</code></pre><p>between and范围查询 : select 字段1，字段2 frome 表名 where 字段 [not] between 取值1 and 取值2;</p><pre><code>select * from student where age between 21 and 29;select * from student where age not between 21 and 29;</code></pre><p>like模糊查询 : select 字段1，字段2… frome 表名 where 字段 [not] like ‘字符串’； “%”代表任意字符；“_”代表单个字符；</p><pre><code>select * frome student where stuName like &apos;%张三%&apos;;//含有张三的任意字符select * frome student where stuName like &apos;张三_&apos;;//张三开头长度为三</code></pre><p>空值查询 : select 字段1，字段2…frome 表名 where 字段  is [not] null;</p><p>and多条件查询 : select 字段1，字段2…frome 表名 where 条件表达式1 and 条件表达式2 [and 条件表达式n]</p><p>or多条件查询 : select 字段1，字段2…frome 表名 where 条件表达式1 or 条件表达式2 [or 条件表达式n]</p><pre><code>select * frome student where gradeName=&apos;一年级&apos; or age=23;//或者，条件只要满足一个</code></pre><p>distinct去重复查询 : select distinct 字段名 from 表名；</p><p>对查询结果排序order by : select 字段1，字段2…from 表名 order by 属性名 [asc|desc]</p><pre><code>select * frome student order by age desc;//降序，从大到小select * frome student order by age asc;//升序，asc默认可以不写</code></pre><p>分组查询group by : group by 属性名 [having 条件表达式][with rollup]</p><ol><li>不能单独使用</li><li><p>与group_concat()函数一起使用，显示具有相同gradeName的stuName</p><pre><code>select gradeName,group_concat(stuName) from student group by gradeName;</code></pre></li><li><p>与聚合函数一起使用，显示具有相同gradeName的stuName数量</p><pre><code>select gradeName,count(stuName) from student group by gradeName;</code></pre></li><li><p>与having一起使用，显示显示具有相同gradeName的stuName&gt;3的数量</p><pre><code>select gradeName,count(stuName) from student group by gradeName having count(stuName)&gt;3;</code></pre></li><li><p>与with rollup 一起使用，最后加入一个总和行</p><pre><code>select gradeName,group_concat(stuName) from student group by gradeName with rollup;</code></pre><p>limit 分页查询 : select 字段1，字段2，…from 表名 limit 初始位置，记录数;</p><pre><code>select * from student limit 0,5;</code></pre></li></ol><h2 id="多表连接查询"><a href="#多表连接查询" class="headerlink" title="多表连接查询"></a>多表连接查询</h2><p>内连接查询：两张或以上的表连接起来查询需要的数据，inner join 是比较运算符，只返回符合条件的行</p><pre><code>select * from book,bookType where book.bookTypeId=bookType.id;select * from book inner join bookType on book.bookTypeId=bookType.id;</code></pre><p>查询某几个字段</p><pre><code>select bookNme,author from book,bookType where book.bookTypeId=bookType.id;</code></pre><p>外连接查询：两张或以上的表连接起来查询某张表的信息<br>左连接：用left join 或 left outer join，包含左表所有行，如果左表中某行在右表没有匹配，则结果中对应行右表的部分全部为空(NULL)</p><pre><code>select * from t_book left join bookType on book.bookTypeId=bookType.id;</code></pre><p>右连接：right join 或 right outer join，包含右表所有行，如果左表中某行在右表没有匹配，则结果中对应左表的部分全部为空(NULL)</p><pre><code>select * from t_book right join bookType on book.bookTypeId=bookType.id;</code></pre><p>完全外连接：full join 或 full outer join，包含full join左右两表中所有的行，如果右表中某行在左表中没有匹配，则结果中对应行右表的部分全部为空(NULL)，如果左表中某行在右表中没有匹配，则结果中对应行左表的部分全部为空(NULL)</p><pre><code>select * from t_book full join bookType on book.bookTypeId=bookType.id;</code></pre><p>交叉连接：cross join，没有 WHERE 子句的交叉联接将产生连接所涉及的表的笛卡尔积。第一个表的行数乘以第二个表的行数等于笛卡尔积结果集的大小</p><pre><code>select * from t_book cross join bookType</code></pre><p>如果我们在此时给这条SQL加上WHERE子句的时候比如SQL：</p><pre><code>select * from t_book cross join bookType where book.bookTypeId=bookType.id;</code></pre><p>此时将返回符合条件的结果集，结果和inner join所示执行结果一样。</p><p>当两表为多对多的时候<br>表student</p><table><thead><tr><th style="text-align:center">SNo</th><th style="text-align:center">SName</th></tr></thead><tbody><tr><td style="text-align:center">S001</td><td style="text-align:center">张三</td></tr><tr><td style="text-align:center">S002</td><td style="text-align:center">李四</td></tr><tr><td style="text-align:center">S003</td><td style="text-align:center">王二</td></tr></tbody></table><p>表course</p><table><thead><tr><th style="text-align:center">CNo</th><th style="text-align:center">CName</th></tr></thead><tbody><tr><td style="text-align:center">C001</td><td style="text-align:center">体育</td></tr><tr><td style="text-align:center">C002</td><td style="text-align:center">音乐</td></tr><tr><td style="text-align:center">C003</td><td style="text-align:center">美术</td></tr></tbody></table><p>表student_course</p><table><thead><tr><th style="text-align:center">ID</th><th style="text-align:center">SNo</th><th style="text-align:center">CNo</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">S001</td><td style="text-align:center">C001</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">S002</td><td style="text-align:center">C001</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">S002</td><td style="text-align:center">C002</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">S003</td><td style="text-align:center">C003</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">S003</td><td style="text-align:center">C001</td></tr></tbody></table><p>一个学生可以选择多门课程，一门课程可以被多个学生选择，因此学生表student和课程表course之间是多对多的关系，SQL语句</p><pre><code>select s.Name,C.Cname from student_course as sc left join student as s on s.Sno=sc.Sno left join course as c on c.Cno=sc.Cno;</code></pre><p>结果如下：</p><table><thead><tr><th style="text-align:center">SName</th><th style="text-align:center">CName</th></tr></thead><tbody><tr><td style="text-align:center">张三</td><td style="text-align:center">体育</td></tr><tr><td style="text-align:center">李四</td><td style="text-align:center">体育</td></tr><tr><td style="text-align:center">李四</td><td style="text-align:center">音乐</td></tr><tr><td style="text-align:center">王二</td><td style="text-align:center">美术</td></tr><tr><td style="text-align:center">王二</td><td style="text-align:center">体育</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;SQL-DML-和-DDL&quot;&gt;&lt;a href=&quot;#SQL-DML-和-DDL&quot; class=&quot;headerlink&quot; title=&quot;SQL DML 和 DDL&quot;&gt;&lt;/a&gt;SQL DML 和 DDL&lt;/h2&gt;&lt;p&gt;可以把 SQL 分为两个部分：数据操作语言 (DML
      
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="知识点" scheme="http://yoursite.com/tags/%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    
      <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Java设计模式(三)</title>
    <link href="http://yoursite.com/2018/06/04/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F(%E4%B8%89)/"/>
    <id>http://yoursite.com/2018/06/04/Java设计模式(三)/</id>
    <published>2018-06-04T11:38:14.000Z</published>
    <updated>2018-06-04T12:32:18.534Z</updated>
    
    <content type="html"><![CDATA[<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。<br>这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。<br><strong>优点</strong>：1、在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如管理学院首页页面缓存）。2、避免对资源的多重占用（比如写文件操作）。<br><strong>缺点</strong>：没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。<br><strong>应用实例</strong>：1、一个党只能有一个主席。 2、Windows 是多进程多线程的，在操作一个文件的时候，就不可避免地出现多个进程或线程同时操作一个文件的现象，所以所有文件的处理必须通过唯一的实例来进行。 3、一些设备管理器常常设计为单例模式，比如一个电脑有两台打印机，在输出的时候就要处理不能两台打印机打印同一个文件。<br><strong>使用场景</strong>：1、要求生产唯一序列号。 2、WEB 中的计数器，不用每次刷新都在数据库里加一次，用单例先缓存起来。 3、创建的一个对象需要消耗的资源过多，比如 I/O 与数据库的连接等。<br><strong>注意事项</strong>：1、单例类只能有一个实例。2、单例类必须自己创建自己的唯一实例。3、单例类必须给所有其他对象提供这一实例。</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>我们将创建一个 SingleObject 类。SingleObject 类有它的私有构造函数和本身的一个静态实例。</p><p>SingleObject 类提供了一个静态方法，供外界获取它的静态实例。SingletonPatternDemo，我们的演示类使用 SingleObject 类来获取 SingleObject 对象。</p><h4 id="步骤-1-创建一个-Singleton-类"><a href="#步骤-1-创建一个-Singleton-类" class="headerlink" title="步骤 1 创建一个 Singleton 类"></a><strong>步骤 1 创建一个 Singleton 类</strong></h4><p>SingleObject.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class SingleObject &#123;</span><br><span class="line"></span><br><span class="line">   //创建 SingleObject 的一个对象</span><br><span class="line">   private static SingleObject instance = new SingleObject();</span><br><span class="line"></span><br><span class="line">   //让构造函数为 private，这样该类就不会被实例化</span><br><span class="line">   private SingleObject()&#123;&#125;</span><br><span class="line"></span><br><span class="line">   //获取唯一可用的对象</span><br><span class="line">   public static SingleObject getInstance()&#123;</span><br><span class="line">      return instance;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public void showMessage()&#123;</span><br><span class="line">      System.out.println(&quot;Hello World!&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="步骤-2-从-singleton-类获取唯一的对象"><a href="#步骤-2-从-singleton-类获取唯一的对象" class="headerlink" title="步骤 2 从 singleton 类获取唯一的对象"></a><strong>步骤 2 从 singleton 类获取唯一的对象</strong></h4><p>SingletonPatternDemo.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class SingletonPatternDemo &#123;</span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">      //不合法的构造函数</span><br><span class="line">      //编译时错误：构造函数 SingleObject() 是不可见的</span><br><span class="line">      //SingleObject object = new SingleObject();</span><br><span class="line"></span><br><span class="line">      //获取唯一可用的对象</span><br><span class="line">      SingleObject object = SingleObject.getInstance();</span><br><span class="line"></span><br><span class="line">      //显示消息</span><br><span class="line">      object.showMessage();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="步骤-3-验证输出"><a href="#步骤-3-验证输出" class="headerlink" title="步骤 3 验证输出"></a><strong>步骤 3 验证输出</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello World!</span><br></pre></td></tr></table></figure><h3 id="单例模式的几种实现方式"><a href="#单例模式的几种实现方式" class="headerlink" title="单例模式的几种实现方式"></a>单例模式的几种实现方式</h3><h4 id="1-懒汉式，线程不安全"><a href="#1-懒汉式，线程不安全" class="headerlink" title="1 懒汉式，线程不安全"></a><strong>1 懒汉式，线程不安全</strong></h4><p><strong>是否 Lazy 初始化</strong>：是<br><strong>是否多线程安全</strong>：否<br><strong>实现难度</strong>：易</p><p><strong>描述</strong>：这种方式是最基本的实现方式，这种实现最大的问题就是不支持多线程。因为没有加锁 synchronized，所以严格意义上它并不算单例模式。<br>这种方式 lazy loading 很明显，不要求线程安全，在多线程不能正常工作。</p><p><strong>代码实例</strong>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;  </span><br><span class="line">    private static Singleton instance;  </span><br><span class="line">    private Singleton ()&#123;&#125;  </span><br><span class="line">  </span><br><span class="line">    public static Singleton getInstance() &#123;  </span><br><span class="line">    if (instance == null) &#123;  </span><br><span class="line">        instance = new Singleton();  </span><br><span class="line">    &#125;  </span><br><span class="line">    return instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="2-懒汉式，线程安全"><a href="#2-懒汉式，线程安全" class="headerlink" title="2 懒汉式，线程安全"></a><strong>2 懒汉式，线程安全</strong></h4><p><strong>是否 Lazy 初始化</strong>：是<br><strong>是否多线程安全</strong>：是<br><strong>实现难度</strong>：易</p><p><strong>描述</strong>：这种方式具备很好的 lazy loading，能够在多线程中很好的工作，但是，效率很低，99% 情况下不需要同步。<br><strong>优点</strong>：第一次调用才初始化，避免内存浪费。<br><strong>缺点</strong>：必须加锁 synchronized 才能保证单例，但加锁会影响效率。<br>getInstance() 的性能对应用程序不是很关键（该方法使用不太频繁）。</p><p><strong>代码实例</strong>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;  </span><br><span class="line">    private static Singleton instance;  </span><br><span class="line">    private Singleton ()&#123;&#125;  </span><br><span class="line">    public static synchronized Singleton getInstance() &#123;  </span><br><span class="line">    if (instance == null) &#123;  </span><br><span class="line">        instance = new Singleton();  </span><br><span class="line">    &#125;  </span><br><span class="line">    return instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="3-饿汉式"><a href="#3-饿汉式" class="headerlink" title="3 饿汉式"></a><strong>3 饿汉式</strong></h4><p><strong>是否 Lazy 初始化</strong>：否<br><strong>是否多线程安全</strong>：是<br><strong>实现难度</strong>：易</p><p><strong>描述</strong>：这种方式比较常用，但容易产生垃圾对象。<br><strong>优点</strong>：没有加锁，执行效率会提高。<br><strong>缺点</strong>：类加载时就初始化，浪费内存。<br>它基于 classloder 机制避免了多线程的同步问题，不过，instance 在类装载时就实例化，虽然导致类装载的原因有很多种，在单例模式中大多数都是调用 getInstance 方法， 但是也不能确定有其他的方式（或者其他的静态方法）导致类装载，这时候初始化 instance 显然没有达到 lazy loading 的效果。</p><p><strong>代码实例</strong>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;  </span><br><span class="line">    private static Singleton instance = new Singleton();  </span><br><span class="line">    private Singleton ()&#123;&#125;  </span><br><span class="line">    public static Singleton getInstance() &#123;  </span><br><span class="line">    return instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="4-双检锁-双重校验锁（DCL，即-double-checked-locking）"><a href="#4-双检锁-双重校验锁（DCL，即-double-checked-locking）" class="headerlink" title="4 双检锁/双重校验锁（DCL，即 double-checked locking）"></a><strong>4 双检锁/双重校验锁（DCL，即 double-checked locking）</strong></h4><p><strong>JDK 版本</strong>：JDK1.5 起<br><strong>是否 Lazy 初始化</strong>：是<br><strong>是否多线程安全</strong>：是<br><strong>实现难度</strong>：较复杂</p><p><strong>描述</strong>：这种方式采用双锁机制，安全且在多线程情况下能保持高性能。<br>getInstance() 的性能对应用程序很关键。</p><p><strong>代码实例</strong>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;  </span><br><span class="line">    private volatile static Singleton singleton;  </span><br><span class="line">    private Singleton ()&#123;&#125;  </span><br><span class="line">    public static Singleton getSingleton() &#123;  </span><br><span class="line">    if (singleton == null) &#123;  </span><br><span class="line">        synchronized (Singleton.class) &#123;  </span><br><span class="line">        if (singleton == null) &#123;  </span><br><span class="line">            singleton = new Singleton();  </span><br><span class="line">        &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    return singleton;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="5-登记式-静态内部类"><a href="#5-登记式-静态内部类" class="headerlink" title="5 登记式/静态内部类"></a><strong>5 登记式/静态内部类</strong></h4><p><strong>是否 Lazy 初始化</strong>：是<br><strong>是否多线程安全</strong>：是<br><strong>实现难度</strong>：一般</p><p><strong>描述</strong>：这种方式能达到双检锁方式一样的功效，但实现更简单。对静态域使用延迟初始化，应使用这种方式而不是双检锁方式。这种方式只适用于静态域的情况，双检锁方式可在实例域需要延迟初始化时使用。<br>这种方式同样利用了 classloder 机制来保证初始化 instance 时只有一个线程，它跟第 3 种方式不同的是：第 3 种方式只要 Singleton 类被装载了，那么 instance 就会被实例化（没有达到 lazy loading 效果），而这种方式是 Singleton 类被装载了，instance 不一定被初始化。因为 SingletonHolder 类没有被主动使用，只有通过显式调用 getInstance 方法时，才会显式装载 SingletonHolder 类，从而实例化 instance。想象一下，如果实例化 instance 很消耗资源，所以想让它延迟加载，另外一方面，又不希望在 Singleton 类加载时就实例化，因为不能确保 Singleton 类还可能在其他的地方被主动使用从而被加载，那么这个时候实例化 instance 显然是不合适的。这个时候，这种方式相比第 3 种方式就显得很合理。</p><p><strong>代码实例</strong>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;  </span><br><span class="line">    private static class SingletonHolder &#123;  </span><br><span class="line">    private static final Singleton INSTANCE = new Singleton();  </span><br><span class="line">    &#125;  </span><br><span class="line">    private Singleton ()&#123;&#125;  </span><br><span class="line">    public static final Singleton getInstance() &#123;  </span><br><span class="line">    return SingletonHolder.INSTANCE;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="6-枚举"><a href="#6-枚举" class="headerlink" title="6 枚举"></a><strong>6 枚举</strong></h4><p><strong>JDK 版本</strong>：JDK1.5 起<br><strong>是否 Lazy 初始化</strong>：否<br><strong>是否多线程安全</strong>：是<br><strong>实现难度</strong>：易</p><p><strong>描述</strong>：这种实现方式还没有被广泛采用，但这是实现单例模式的最佳方法。它更简洁，自动支持序列化机制，绝对防止多次实例化。<br>这种方式是 Effective Java 作者 Josh Bloch 提倡的方式，它不仅能避免多线程同步问题，而且还自动支持序列化机制，防止反序列化重新创建新的对象，绝对防止多次实例化。不过，由于 JDK1.5 之后才加入 enum 特性，用这种方式写不免让人感觉生疏，在实际工作中，也很少用。<br>不能通过 reflection attack 来调用私有构造方法。</p><p><strong>代码实例</strong>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public enum Singleton &#123;  </span><br><span class="line">    INSTANCE;  </span><br><span class="line">    public void whateverMethod() &#123;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>一般情况下，不建议使用第 1 种和第 2 种懒汉方式，建议使用第 3 种饿汉方式。只有在要明确实现 lazy loading 效果时，才会使用第 5 种登记方式。如果涉及到反序列化创建对象时，可以尝试使用第 6 种枚举方式。如果有其他特殊的需求，可以考虑使用第 4 种双检锁方式。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;单例模式&quot;&gt;&lt;a href=&quot;#单例模式&quot; class=&quot;headerlink&quot; title=&quot;单例模式&quot;&gt;&lt;/a&gt;单例模式&lt;/h2&gt;&lt;h3 id=&quot;描述&quot;&gt;&lt;a href=&quot;#描述&quot; class=&quot;headerlink&quot; title=&quot;描述&quot;&gt;&lt;/a&gt;描述&lt;/h
      
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="知识点" scheme="http://yoursite.com/tags/%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    
  </entry>
  
  <entry>
    <title>Java设计模式(二)</title>
    <link href="http://yoursite.com/2018/04/10/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F(%E4%BA%8C)/"/>
    <id>http://yoursite.com/2018/04/10/Java设计模式(二)/</id>
    <published>2018-04-10T11:33:19.000Z</published>
    <updated>2018-04-17T07:15:52.225Z</updated>
    
    <content type="html"><![CDATA[<h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>工厂模式是一种创建型模式，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。<br><strong>优点</strong>： 1、一个调用者想创建一个对象，只要知道其名称就可以了。 2、扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。 3、屏蔽产品的具体实现，调用者只关心产品的接口。<br><strong>缺点</strong>：每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖，不便于维护。<br><strong>应用实例</strong>：1、您需要一辆汽车，可以直接从工厂里面提货，而不用去管这辆汽车是怎么做出来的，以及这个汽车里面的具体实现。 2、Hibernate 换数据库只需换方言和驱动就可以。<br><strong>使用场景</strong>： 1、日志记录器：记录可能记录到本地硬盘、系统事件、远程服务器等，用户可以选择记录日志到什么地方。 2、数据库访问，当用户不知道最后系统采用哪一类数据库，以及数据库可能有变化时。 3、设计一个连接服务器的框架，需要三个协议，”POP3”、”IMAP”、”HTTP”，可以把这三个作为产品类，共同实现一个接口。<br><strong>注意事项</strong>：作为一种创建类模式，在任何需要生成复杂对象的地方，都可以使用工厂方法模式。有一点需要注意的地方就是复杂对象适合使用工厂模式，而简单对象，特别是只需要通过 new 就可以完成创建的对象，无需使用工厂模式。如果使用工厂模式，就需要引入一个工厂类，会增加系统的复杂度。</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>先创建Shape接口和Shape接口的实现类，然后再定义ShapeFactory</p><h4 id="步骤-1-创建接口"><a href="#步骤-1-创建接口" class="headerlink" title="步骤 1 创建接口"></a><strong>步骤 1 创建接口</strong></h4><p>shape.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface Shape &#123;</span><br><span class="line">   void draw();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="步骤-2-创建接口的实现类"><a href="#步骤-2-创建接口的实现类" class="headerlink" title="步骤 2 创建接口的实现类"></a><strong>步骤 2 创建接口的实现类</strong></h4><p>Rectangle.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Rectangle implements Shape &#123;</span><br><span class="line"></span><br><span class="line">   @Override</span><br><span class="line">   public void draw() &#123;</span><br><span class="line">      System.out.println(&quot;Inside Rectangle::draw() method.&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Square.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Square implements Shape &#123;</span><br><span class="line"></span><br><span class="line">   @Override</span><br><span class="line">   public void draw() &#123;</span><br><span class="line">      System.out.println(&quot;Inside Square::draw() method.&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Circle.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Circle implements Shape &#123;</span><br><span class="line"></span><br><span class="line">   @Override</span><br><span class="line">   public void draw() &#123;</span><br><span class="line">      System.out.println(&quot;Inside Circle::draw() method.&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="步骤-3-创建一个工厂，生成基于给定信息的实体类的对象"><a href="#步骤-3-创建一个工厂，生成基于给定信息的实体类的对象" class="headerlink" title="步骤 3 创建一个工厂，生成基于给定信息的实体类的对象"></a><strong>步骤 3 创建一个工厂，生成基于给定信息的实体类的对象</strong></h4><p>ShapeFactory.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class ShapeFactory &#123;</span><br><span class="line">    </span><br><span class="line">   //使用 getShape 方法获取形状类型的对象</span><br><span class="line">   public Shape getShape(String shapeType)&#123;</span><br><span class="line">      if(shapeType == null)&#123;</span><br><span class="line">         return null;</span><br><span class="line">      &#125;        </span><br><span class="line">      if(shapeType.equalsIgnoreCase(&quot;CIRCLE&quot;))&#123;</span><br><span class="line">         return new Circle();</span><br><span class="line">      &#125; else if(shapeType.equalsIgnoreCase(&quot;RECTANGLE&quot;))&#123;</span><br><span class="line">         return new Rectangle();</span><br><span class="line">      &#125; else if(shapeType.equalsIgnoreCase(&quot;SQUARE&quot;))&#123;</span><br><span class="line">         return new Square();</span><br><span class="line">      &#125;</span><br><span class="line">      return null;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="步骤-4-使用该工厂，通过传递类型信息来获取实体类的对象"><a href="#步骤-4-使用该工厂，通过传递类型信息来获取实体类的对象" class="headerlink" title="步骤 4 使用该工厂，通过传递类型信息来获取实体类的对象"></a><strong>步骤 4 使用该工厂，通过传递类型信息来获取实体类的对象</strong></h4><p>FactoryPatternDemo.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class FactoryPatternDemo &#123;</span><br><span class="line"></span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">      ShapeFactory shapeFactory = new ShapeFactory();</span><br><span class="line"></span><br><span class="line">      //获取 Circle 的对象，并调用它的 draw 方法</span><br><span class="line">      Shape shape1 = shapeFactory.getShape(&quot;CIRCLE&quot;);</span><br><span class="line"></span><br><span class="line">      //调用 Circle 的 draw 方法</span><br><span class="line">      shape1.draw();</span><br><span class="line"></span><br><span class="line">      //获取 Rectangle 的对象，并调用它的 draw 方法</span><br><span class="line">      Shape shape2 = shapeFactory.getShape(&quot;RECTANGLE&quot;);</span><br><span class="line"></span><br><span class="line">      //调用 Rectangle 的 draw 方法</span><br><span class="line">      shape2.draw();</span><br><span class="line"></span><br><span class="line">      //获取 Square 的对象，并调用它的 draw 方法</span><br><span class="line">      Shape shape3 = shapeFactory.getShape(&quot;SQUARE&quot;);</span><br><span class="line"></span><br><span class="line">      //调用 Square 的 draw 方法</span><br><span class="line">      shape3.draw();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h2><h3 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h3><p>抽象工厂模式是围绕一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。在抽象工厂模式中，接口是负责创建一个相关对象的工厂，不需要显式指定它们的类。每个生成的工厂都能按照工厂模式提供对象。<br><strong>优点</strong>：当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象。<br><strong>缺点</strong>：产品族扩展非常困难，要增加一个系列的某一产品，既要在抽象的 Creator 里加代码，又要在具体的里面加代码。<br><strong>应用实例</strong>：一个人会有多套衣服，休闲装 、商务装、运动装等，这些衣服都是成套存在的，即是一系列的具体产品。假设在家里有多个衣柜，某一个衣柜只存放一种成套衣服，每次要拿这种成套的衣服也自然是在这个衣柜中取出。用oo的思想去理解，所有的衣柜（具体工厂）都是衣柜类（抽象工厂）的某一个，而每件成套的衣服又包括具体的上衣、裤子（某一具体产品），这些具体的上衣都是上衣（抽象产品），具体的裤子也是裤子（抽象产品）。<br><strong>使用场景</strong>： 1、QQ 换皮肤，一整套一起换。 2、生成不同操作系统的程序。<br><strong>注意事项</strong>：产品族难扩展，产品等级易扩展。</p><h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><p>先创建 Shape 和 Color 接口和实现这些接口的实体类；然后创建抽象工厂类 AbstractFactory；接着定义工厂类 ShapeFactory 和 ColorFactory，这两个工厂类都是扩展了 AbstractFactory；最后创建一个工厂创造器/生成器类 FactoryProducer。</p><h4 id="步骤-1-为形状创建一个接口"><a href="#步骤-1-为形状创建一个接口" class="headerlink" title="步骤 1 为形状创建一个接口"></a><strong>步骤 1 为形状创建一个接口</strong></h4><p>Shape.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface Shape &#123;</span><br><span class="line">   void draw();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="步骤-2-创建实现接口的实体类"><a href="#步骤-2-创建实现接口的实体类" class="headerlink" title="步骤 2 创建实现接口的实体类"></a><strong>步骤 2 创建实现接口的实体类</strong></h4><p>Rectangle.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Rectangle implements Shape &#123;</span><br><span class="line"></span><br><span class="line">   @Override</span><br><span class="line">   public void draw() &#123;</span><br><span class="line">      System.out.println(&quot;Inside Rectangle::draw() method.&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Square.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Square implements Shape &#123;</span><br><span class="line"></span><br><span class="line">   @Override</span><br><span class="line">   public void draw() &#123;</span><br><span class="line">      System.out.println(&quot;Inside Square::draw() method.&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Circle.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Circle implements Shape &#123;</span><br><span class="line"></span><br><span class="line">   @Override</span><br><span class="line">   public void draw() &#123;</span><br><span class="line">      System.out.println(&quot;Inside Circle::draw() method.&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="步骤-3-为颜色创建一个接口"><a href="#步骤-3-为颜色创建一个接口" class="headerlink" title="步骤 3 为颜色创建一个接口"></a><strong>步骤 3 为颜色创建一个接口</strong></h4><p>Color.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface Color &#123;</span><br><span class="line">   void fill();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="步骤-4-创建实现接口的实体类"><a href="#步骤-4-创建实现接口的实体类" class="headerlink" title="步骤 4 创建实现接口的实体类"></a><strong>步骤 4 创建实现接口的实体类</strong></h4><p>Red.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Red implements Color &#123;</span><br><span class="line"></span><br><span class="line">   @Override</span><br><span class="line">   public void fill() &#123;</span><br><span class="line">      System.out.println(&quot;Inside Red::fill() method.&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Green.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Green implements Color &#123;</span><br><span class="line"></span><br><span class="line">   @Override</span><br><span class="line">   public void fill() &#123;</span><br><span class="line">      System.out.println(&quot;Inside Green::fill() method.&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Blue.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Blue implements Color &#123;</span><br><span class="line"></span><br><span class="line">   @Override</span><br><span class="line">   public void fill() &#123;</span><br><span class="line">      System.out.println(&quot;Inside Blue::fill() method.&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="步骤-5-为-Color-和-Shape-对象创建抽象类来获取工厂"><a href="#步骤-5-为-Color-和-Shape-对象创建抽象类来获取工厂" class="headerlink" title="步骤 5 为 Color 和 Shape 对象创建抽象类来获取工厂"></a><strong>步骤 5 为 Color 和 Shape 对象创建抽象类来获取工厂</strong></h4><p>AbstractFactory.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public abstract class AbstractFactory &#123;</span><br><span class="line">   abstract Color getColor(String color);</span><br><span class="line">   abstract Shape getShape(String shape) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="步骤-6-创建扩展了-AbstractFactory-的工厂类，基于给定的信息生成实体类的对象"><a href="#步骤-6-创建扩展了-AbstractFactory-的工厂类，基于给定的信息生成实体类的对象" class="headerlink" title="步骤 6 创建扩展了 AbstractFactory 的工厂类，基于给定的信息生成实体类的对象"></a><strong>步骤 6 创建扩展了 AbstractFactory 的工厂类，基于给定的信息生成实体类的对象</strong></h4><p>ShapeFactory.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class ShapeFactory extends AbstractFactory &#123;</span><br><span class="line">    </span><br><span class="line">   @Override</span><br><span class="line">   public Shape getShape(String shapeType)&#123;</span><br><span class="line">      if(shapeType == null)&#123;</span><br><span class="line">         return null;</span><br><span class="line">      &#125;        </span><br><span class="line">      if(shapeType.equalsIgnoreCase(&quot;CIRCLE&quot;))&#123;</span><br><span class="line">         return new Circle();</span><br><span class="line">      &#125; else if(shapeType.equalsIgnoreCase(&quot;RECTANGLE&quot;))&#123;</span><br><span class="line">         return new Rectangle();</span><br><span class="line">      &#125; else if(shapeType.equalsIgnoreCase(&quot;SQUARE&quot;))&#123;</span><br><span class="line">         return new Square();</span><br><span class="line">      &#125;</span><br><span class="line">      return null;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   @Override</span><br><span class="line">   Color getColor(String color) &#123;</span><br><span class="line">      return null;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>ColorFactory.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class ColorFactory extends AbstractFactory &#123;</span><br><span class="line">    </span><br><span class="line">   @Override</span><br><span class="line">   public Shape getShape(String shapeType)&#123;</span><br><span class="line">      return null;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   @Override</span><br><span class="line">   Color getColor(String color) &#123;</span><br><span class="line">      if(color == null)&#123;</span><br><span class="line">         return null;</span><br><span class="line">      &#125;        </span><br><span class="line">      if(color.equalsIgnoreCase(&quot;RED&quot;))&#123;</span><br><span class="line">         return new Red();</span><br><span class="line">      &#125; else if(color.equalsIgnoreCase(&quot;GREEN&quot;))&#123;</span><br><span class="line">         return new Green();</span><br><span class="line">      &#125; else if(color.equalsIgnoreCase(&quot;BLUE&quot;))&#123;</span><br><span class="line">         return new Blue();</span><br><span class="line">      &#125;</span><br><span class="line">      return null;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="步骤-7-创建一个工厂创造器-生成器类，通过传递形状或颜色信息来获取工厂"><a href="#步骤-7-创建一个工厂创造器-生成器类，通过传递形状或颜色信息来获取工厂" class="headerlink" title="步骤 7 创建一个工厂创造器/生成器类，通过传递形状或颜色信息来获取工厂"></a><strong>步骤 7 创建一个工厂创造器/生成器类，通过传递形状或颜色信息来获取工厂</strong></h4><p>FactoryProducer.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class FactoryProducer &#123;</span><br><span class="line">   public static AbstractFactory getFactory(String choice)&#123;</span><br><span class="line">      if(choice.equalsIgnoreCase(&quot;SHAPE&quot;))&#123;</span><br><span class="line">         return new ShapeFactory();</span><br><span class="line">      &#125; else if(choice.equalsIgnoreCase(&quot;COLOR&quot;))&#123;</span><br><span class="line">         return new ColorFactory();</span><br><span class="line">      &#125;</span><br><span class="line">      return null;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="步骤-8-使用-FactoryProducer-来获取-AbstractFactory，通过传递类型信息来获取实体类的对象"><a href="#步骤-8-使用-FactoryProducer-来获取-AbstractFactory，通过传递类型信息来获取实体类的对象" class="headerlink" title="步骤 8 使用 FactoryProducer 来获取 AbstractFactory，通过传递类型信息来获取实体类的对象"></a><strong>步骤 8 使用 FactoryProducer 来获取 AbstractFactory，通过传递类型信息来获取实体类的对象</strong></h4><p>AbstractFactoryPatternDemo.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">public class AbstractFactoryPatternDemo &#123;</span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">      //获取形状工厂</span><br><span class="line">      AbstractFactory shapeFactory = FactoryProducer.getFactory(&quot;SHAPE&quot;);</span><br><span class="line"></span><br><span class="line">      //获取形状为 Circle 的对象</span><br><span class="line">      Shape shape1 = shapeFactory.getShape(&quot;CIRCLE&quot;);</span><br><span class="line"></span><br><span class="line">      //调用 Circle 的 draw 方法</span><br><span class="line">      shape1.draw();</span><br><span class="line"></span><br><span class="line">      //获取形状为 Rectangle 的对象</span><br><span class="line">      Shape shape2 = shapeFactory.getShape(&quot;RECTANGLE&quot;);</span><br><span class="line"></span><br><span class="line">      //调用 Rectangle 的 draw 方法</span><br><span class="line">      shape2.draw();</span><br><span class="line">      </span><br><span class="line">      //获取形状为 Square 的对象</span><br><span class="line">      Shape shape3 = shapeFactory.getShape(&quot;SQUARE&quot;);</span><br><span class="line"></span><br><span class="line">      //调用 Square 的 draw 方法</span><br><span class="line">      shape3.draw();</span><br><span class="line"></span><br><span class="line">      //获取颜色工厂</span><br><span class="line">      AbstractFactory colorFactory = FactoryProducer.getFactory(&quot;COLOR&quot;);</span><br><span class="line"></span><br><span class="line">      //获取颜色为 Red 的对象</span><br><span class="line">      Color color1 = colorFactory.getColor(&quot;RED&quot;);</span><br><span class="line"></span><br><span class="line">      //调用 Red 的 fill 方法</span><br><span class="line">      color1.fill();</span><br><span class="line"></span><br><span class="line">      //获取颜色为 Green 的对象</span><br><span class="line">      Color color2 = colorFactory.getColor(&quot;Green&quot;);</span><br><span class="line"></span><br><span class="line">      //调用 Green 的 fill 方法</span><br><span class="line">      color2.fill();</span><br><span class="line"></span><br><span class="line">      //获取颜色为 Blue 的对象</span><br><span class="line">      Color color3 = colorFactory.getColor(&quot;BLUE&quot;);</span><br><span class="line"></span><br><span class="line">      //调用 Blue 的 fill 方法</span><br><span class="line">      color3.fill();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;工厂模式&quot;&gt;&lt;a href=&quot;#工厂模式&quot; class=&quot;headerlink&quot; title=&quot;工厂模式&quot;&gt;&lt;/a&gt;工厂模式&lt;/h2&gt;&lt;h3 id=&quot;描述&quot;&gt;&lt;a href=&quot;#描述&quot; class=&quot;headerlink&quot; title=&quot;描述&quot;&gt;&lt;/a&gt;描述&lt;/h
      
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="知识点" scheme="http://yoursite.com/tags/%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    
  </entry>
  
  <entry>
    <title>Java设计模式(一)</title>
    <link href="http://yoursite.com/2018/04/09/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F(%E4%B8%80)/"/>
    <id>http://yoursite.com/2018/04/09/Java设计模式(一)/</id>
    <published>2018-04-09T10:15:41.000Z</published>
    <updated>2018-04-10T10:25:30.637Z</updated>
    
    <content type="html"><![CDATA[<h1 id="设计模式简介"><a href="#设计模式简介" class="headerlink" title="设计模式简介"></a>设计模式简介</h1><blockquote><p>设计模式是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了重用代码、让代码更容易被他人理解、保证代码可靠性。 毫无疑问，设计模式于己于他人于系统都是多赢的，设计模式使代码编制真正工程化，设计模式是软件工程的基石，如同大厦的一块块砖石一样。项目中合理地运用设计模式可以完美地解决很多问题，每种模式在现实中都有相应的原理来与之对应，每种模式都描述了一个在我们周围不断重复发生的问题，以及该问题的核心解决方案，这也是设计模式能被广泛应用的原因。</p></blockquote><h1 id="设计模式分类"><a href="#设计模式分类" class="headerlink" title="设计模式分类"></a>设计模式分类</h1><p>设计模式统共有23种，这23种又分为三大类：创建型模式（Creational Patterns）、结构型模式（Structural Patterns）、行为型模式（Behavioral Patterns），此外，还有J2EE设计模式。</p><table><thead><tr><th style="text-align:left">模式&amp;简述</th><th style="text-align:left">包括</th></tr></thead><tbody><tr><td style="text-align:left"><strong>创建型模式</strong><br>创建对象同时隐藏创建逻辑，而不是使用 new 运算符直接实例化对象，在判断具体实例需要创建哪些对象时更加灵活</td><td style="text-align:left">工厂模式（Factory Pattern）<br>抽象工厂模式（Abstract Factory Pattern）<br>单例模式（Singleton Pattern）<br>建造者模式（Builder Pattern）<br>原型模式（Prototype Pattern）</td></tr><tr><td style="text-align:left"><strong>结构型模式</strong><br>这些设计模式关注类和对象的组合，继承的概念被用来组合接口和定义组合对象获得新功能的方式。</td><td style="text-align:left">适配器模式（Adapter Pattern）<br>桥接模式（Bridge Pattern）<br>过滤器模式（Filter、Criteria Pattern）<br>组合模式（Composite Pattern）<br>装饰器模式（Decorator Pattern）<br>外观模式（Facade Pattern）<br>享元模式（Flyweight Pattern）<br>代理模式（Proxy Pattern）</td></tr><tr><td style="text-align:left"><strong>行为型模式</strong><br>这些模式特别关注对象之间的通信。</td><td style="text-align:left">责任链模式（Chain of Responsibility Pattern）<br>命令模式（Command Pattern）<br>解释器模式（Interpreter Pattern）<br>迭代器模式（Iterator Pattern）<br>中介者模式（Mediator Pattern）<br>备忘录模式（Memento Pattern）<br>观察者模式（Observer Pattern）<br>状态模式（State Pattern）<br>空对象模式（Null Object Pattern）<br>策略模式（Strategy Pattern）<br>模板模式（Template Pattern）<br>访问者模式（Visitor Pattern）</td></tr><tr><td style="text-align:left"><strong>J2EE模式</strong><br>这些设计模式特别关注表示层。</td><td style="text-align:left">MVC 模式（MVC Pattern）<br>业务代表模式（Business Delegate Pattern）<br>组合实体模式（Composite Entity Pattern）<br>数据访问对象模式（Data Access Object Pattern）<br>前端控制器模式（Front Controller Pattern）<br>拦截过滤器模式（Intercepting Filter Pattern）<br> 服务定位器模式（Service Locator Pattern）<br>传输对象模式（Transfer Object Pattern）</td></tr></tbody></table><p>设计模式关系图：<br><img src="https://s1.ax1x.com/2018/04/10/CF4FyR.jpg" alt="关系图"></p><h1 id="设计模式六大原则"><a href="#设计模式六大原则" class="headerlink" title="设计模式六大原则"></a>设计模式六大原则</h1><h3 id="1、开闭原则（Open-Close-Principle）"><a href="#1、开闭原则（Open-Close-Principle）" class="headerlink" title="1、开闭原则（Open Close Principle）"></a>1、开闭原则（Open Close Principle）</h3><p>开闭原则的意思是：对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类。</p><h3 id="2、里氏代换原则（Liskov-Substitution-Principle）"><a href="#2、里氏代换原则（Liskov-Substitution-Principle）" class="headerlink" title="2、里氏代换原则（Liskov Substitution Principle）"></a>2、里氏代换原则（Liskov Substitution Principle）</h3><p>里氏代换原则是面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。LSP 是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为。里氏代换原则是对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。</p><h3 id="3、依赖倒转原则（Dependence-Inversion-Principle）"><a href="#3、依赖倒转原则（Dependence-Inversion-Principle）" class="headerlink" title="3、依赖倒转原则（Dependence Inversion Principle）"></a>3、依赖倒转原则（Dependence Inversion Principle）</h3><p>个原则是开闭原则的基础，具体内容：针对接口编程，依赖于抽象而不依赖于具体。</p><h3 id="4、接口隔离原则（Interface-Segregation-Principle）"><a href="#4、接口隔离原则（Interface-Segregation-Principle）" class="headerlink" title="4、接口隔离原则（Interface Segregation Principle）"></a>4、接口隔离原则（Interface Segregation Principle）</h3><p>这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。它还有另外一个意思是：降低类之间的耦合度。由此可见，其实设计模式就是从大型软件架构出发、便于升级和维护的软件设计思想，它强调降低依赖，降低耦合。</p><h3 id="5、迪米特法则（Demeter-Principle）"><a href="#5、迪米特法则（Demeter-Principle）" class="headerlink" title="5、迪米特法则（Demeter Principle）"></a>5、迪米特法则（Demeter Principle）</h3><p>迪米特法则是指：一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。</p><h3 id="6、合成复用原则（Composite-Reuse-Principle）"><a href="#6、合成复用原则（Composite-Reuse-Principle）" class="headerlink" title="6、合成复用原则（Composite Reuse Principle）"></a>6、合成复用原则（Composite Reuse Principle）</h3><h2 id="合成复用原则是指：尽量使用合成-聚合的方式，而不是使用继承。"><a href="#合成复用原则是指：尽量使用合成-聚合的方式，而不是使用继承。" class="headerlink" title="合成复用原则是指：尽量使用合成/聚合的方式，而不是使用继承。"></a>合成复用原则是指：尽量使用合成/聚合的方式，而不是使用继承。</h2><p>原文 <a href="http://www.runoob.com/design-pattern/design-pattern-tutorial.html" target="_blank" rel="noopener">菜鸟教程</a>参考整理</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;设计模式简介&quot;&gt;&lt;a href=&quot;#设计模式简介&quot; class=&quot;headerlink&quot; title=&quot;设计模式简介&quot;&gt;&lt;/a&gt;设计模式简介&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;设计模式是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结。使用
      
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="知识点" scheme="http://yoursite.com/tags/%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    
  </entry>
  
  <entry>
    <title>我听说</title>
    <link href="http://yoursite.com/2018/03/17/%E6%88%91%E5%90%AC%E8%AF%B4/"/>
    <id>http://yoursite.com/2018/03/17/我听说/</id>
    <published>2018-03-16T21:52:51.965Z</published>
    <updated>2018-03-16T21:58:07.803Z</updated>
    
    <content type="html"><![CDATA[<p>　　我听说，有一种猫叫做雨猫。天气温暖时，它就变得蓬松毛绒绒的，像白云一样上浮，你可以拴着它，像放风筝一样走，它会变透明，阳光透得过它的身体。天气晦暗时它会变黑，坠在地上，满地乱跑，毛变得硬硬的，像刚刮过的胡茬一样。你得抱着它，等天气晴朗时，再把它放出去，就像风筝末梢放着一团棉花糖。</p><p>　　我听说，有种青蛙，透明洁白，只吃茶叶。吃多之后，吐气如兰。冬天它便僵卧，张着大嘴，眠去一个季节。你往它肚里倒热水，水便成茶，馥郁芳香，可以倒在杯子里喝，香沁肺腑。有个女孩子，手头没有杯子，于是捧起青蛙，嘴对着嘴，把青蛙嘴当茶杯口。结果青蛙醒了，变成一白衣少年：“哪个公主吻了我？”</p><p>　　我听说，有一种驯鹿，很爱长颈鹿的斑纹和气味，但是太矮，又碍于长颈鹿是哑巴，所以没法谈恋爱。于是它们就长起了杉树一样直拔云天的角，然后到处找一个人，在角的顶端造一个房子住着。每天，那个人负责在高树摘果子，送给长颈鹿吃，以促成驯鹿和长颈鹿的爱情——虽然见不到面，但灵魂相通的爱情。</p><p>　　我听说，北方有一种松鼠，特别大，毛茸茸的，睡觉时喜欢摊开四肢，露出软绵绵的肚皮。你抓住一只，混熟了，就可以把它当床，睡在它的肚子上，用它的尾巴做被子。但它喜欢梦游，到处爬，所以你睡着前眼睛明明看见天花板的花纹，醒来时就可能看见松树枝、杉树枝、云、麻雀和松毛虫。</p><p>　　我听说，有一种猫，特别怕冷，一遇到冷环境就全身长起蓬松松软绵绵的长毛，并且开始冬眠，怎么叫都不醒。冬天你把它挂在脖子上出门，就好像穿了件毛大衣。到了温暖的室内，它暖醒了，就喵一声跳下来，自己到炉子旁边去接着睡了。因为冬天很长，它在冬天基本是裘状，所以叫冬裘夏猫。</p><p>　　我听说，有种野猪，睡一觉就长一层脂肪，起来跑一跑就练出一层肌肉，所以他身上肥瘦肥瘦，像夹心饼干。他爱去南方的海边泡澡，泡一身大粒子盐味，吹风，然后哼唧哼唧去温泉，一边蒸自己一边吃树叶子。你埋伏在温泉边，射倒它，能吃到现成的蒸火腿。你最好带蜂蜜，敷一遍再蒸，更好吃。</p><p>　　我听说，以前有人喜欢在海蚌上写故事写诗。你走在海边，海蚌会跟你说：我身上有字，可以给你看噢，但有个条件，我不识字，你得念给我听。你答应了，海蚌就张开壳来，让你给它念故事。如果你看入神忘了继续念，或者企图摘抄剽窃，海蚌就会夹你一下；如果你念得好，海蚌就送你颗珍珠。</p><p>　　我听说，南方有一种鸟，身材纤瘦，尾羽很长，善吟诗，平时看上去盈盈一握，却筋骨健壮。如果你和它混熟了，它就会把身体绷直，你可以握着它的腰，用它的嘴蘸墨、写字，画梅花、打印章时，还可以用它印个浅爪痕。可是它挑剔得很，墨质差，纸脏，字写得难看，或者句子毫无文采，它就会破口大骂：“居然用老娘写这么烂的文章！”</p><p>我听说有种雪狐，极妩媚，皮毛柔滑。善学声音，爱恶作剧，喜在窗外学男主人女同学、女同事等声音，引女主人疑心吵架，引以为乐。被抓住后会要求：给你雪狐裘，放我走吧。若男主人不允，她便媚笑：原来是你舍不得我走啊嗯……女主人遂朝男主人双目圆睁：你留她干嘛，还不放走？心思又活络了嗯？！</p><p>　　我听说，有种熊叫做云熊，其白如雪，其大若垂天之云。春天开始浮游，夏天吸取阳光。冬天，它随风在天空飘荡，到一个寒冷的地方，就开始下一团团的熊绒毛。熊绒可做大衣，闻得到夏天阳光的味道。熊绒落完，它也就飘下地来。你闻以蜂蜜，冬眠。到春天它长起了毛，就又变成云浮起来了。</p><p>　　我听说有种蜗牛，寿命很长，以八千岁为春，以八千岁为秋。丈夫对妻子说，我要吻你一下，然后出门去买报纸。妻子就闭上眼，等了八天，吻到了，于是丈夫出门了。等他回来，妻子抱怨说：你这一走就是六百年，我好担心。丈夫说：哎呀，我是怕又过时了，站在那里花二百年把新闻看了嘛。</p><p>　　我听说有种章鱼，善于下厨。你坐柜台后面，问它要三明治寿司刺身铁板烧咖啡茶涮锅烤串回锅肉，它舞起手臂们，切剔炒烹翻炸调撒料颠勺，又快又好，还能剩出三只手，一只负责收钱，两只和你打扑克解闷。但它开不起玩笑，偶尔它不小心手臂被铁板烫到，你可不能说“那我要这条章鱼烧！” 不然它就会舞起锅铲，任你是三头六臂也挡不住它四面八方朝你扔鱼丸。</p><p>　　我听说有种虎鲸，很温柔，喜欢光，不潜游，但又怕晒。你在它背上铺沙子，张阳伞，它便喜欢你，任你在它背上住下，钓鱼、睡午觉、接吻、喝果汁。每天它张嘴吞许多小鱼，自己吃些，剩下的喷水送给你，于是你天天有新鲜刺身吃。偶然它也馋，愿意吃熟的，就会张嘴，要你抛给吃章鱼烧。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;　　我听说，有一种猫叫做雨猫。天气温暖时，它就变得蓬松毛绒绒的，像白云一样上浮，你可以拴着它，像放风筝一样走，它会变透明，阳光透得过它的身体。天气晦暗时它会变黑，坠在地上，满地乱跑，毛变得硬硬的，像刚刮过的胡茬一样。你得抱着它，等天气晴朗时，再把它放出去，就像风筝末梢放着一
      
    
    </summary>
    
      <category term="美文" scheme="http://yoursite.com/categories/%E7%BE%8E%E6%96%87/"/>
    
    
      <category term="随笔" scheme="http://yoursite.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="摘抄" scheme="http://yoursite.com/tags/%E6%91%98%E6%8A%84/"/>
    
  </entry>
  
  <entry>
    <title>Markdown 常用语法(一)</title>
    <link href="http://yoursite.com/2018/03/16/markdown%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95(%E4%B8%80)/"/>
    <id>http://yoursite.com/2018/03/16/markdown常用语法(一)/</id>
    <published>2018-03-15T18:56:30.915Z</published>
    <updated>2018-04-10T10:00:28.114Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Markdown"><a href="#Markdown" class="headerlink" title="Markdown"></a>Markdown</h2><blockquote><p>Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档，然后转换成格式丰富的HTML页面。    —— <a href="https://zh.wikipedia.org/wiki/Markdown" target="_blank"> [ 维基百科 ]</a></p></blockquote><h2 id="修辞和强调"><a href="#修辞和强调" class="headerlink" title="修辞和强调"></a>修辞和强调</h2><p>Markdown 使用星号和底线来标记需要强调的区段。<br>Some of these words <em>are emphasized</em>.<br>Some of these words <em>are emphasized also</em>.<br>Use two asterisks for <strong>strong emphasis</strong>.<br>Or, if you prefer, <strong>use two underscores instead</strong>.</p><h2 id="列表和表格"><a href="#列表和表格" class="headerlink" title="列表和表格"></a>列表和表格</h2><p>无序列表使用星号、加号和减号来做为列表的项目标记，这些符号是都可以使用的，使用<br>星号：</p><pre><code>* Candy.* Gum.* Booze.</code></pre><p>加号：</p><pre><code>+ Candy.+ Gum.+ Booze.</code></pre><p>减号：</p><pre><code>- Candy.- Gum.- Booze.</code></pre><p>全部都显示为：</p><pre><code>&lt;ul&gt;&lt;li&gt;Candy.&lt;/li&gt;&lt;li&gt;Gum.&lt;/li&gt;&lt;li&gt;Booze.&lt;/li&gt;&lt;/ul&gt;</code></pre><p>有序的列表则是使用一般的数字接着一个英文句点作为项目标记：</p><pre><code>1. Red2. Green3. Blue</code></pre><p>显示为：</p><pre><code>&lt;ol&gt;&lt;li&gt;Red&lt;/li&gt;&lt;li&gt;Green&lt;/li&gt;&lt;li&gt;Blue&lt;/li&gt;&lt;/ol&gt;</code></pre><p>可以使用冒号来定义表格对齐方式：</p><pre><code>| 项目      |    价格 | 数量  || :-------- | --------:| :--: || Computer  | 1600 元 |  5   || Phone     |   12 元 |  12  || Pipe      |    1 元 | 234  |</code></pre><p>显示为</p><table><thead><tr><th style="text-align:left">项目</th><th style="text-align:right">价格</th><th style="text-align:center">数量</th></tr></thead><tbody><tr><td style="text-align:left">Computer</td><td style="text-align:right">1600 元</td><td style="text-align:center">5</td></tr><tr><td style="text-align:left">Phone</td><td style="text-align:right">12 元</td><td style="text-align:center">12</td></tr><tr><td style="text-align:left">Pipe</td><td style="text-align:right">1 元</td><td style="text-align:center">234</td></tr></tbody></table><p><strong>Markdown　Extra</strong>　定义列表语法：</p><pre><code>项目１项目２:   定义 A:   定义 B项目３:   定义 C:   定义 D    &gt; 定义D内容</code></pre><p>显示为</p><blockquote><p>项目１<br>项目２<br>:   定义 A<br>:   定义 B</p><p>项目３<br>:   定义 C</p><p>:   定义 D</p><pre><code>&gt; 定义D内容</code></pre></blockquote><h2 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h2><p>代码块语法遵循标准markdown代码，用反引号包起来<br>例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">       <span class="comment">// TODO Auto-generated method stub  </span></span><br><span class="line">       File file = <span class="keyword">new</span> File(<span class="string">"F:\\Tomcat"</span>);  </span><br><span class="line">       list(file);  </span><br><span class="line">       Date myDate = <span class="keyword">new</span> Date();   </span><br><span class="line">       DateFormat df = DateFormat.getDateInstance();  </span><br><span class="line">       System.out.println(df.format(myDate));   </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><h2 id="链接和图片"><a href="#链接和图片" class="headerlink" title="链接和图片"></a>链接和图片</h2><p>Markdown 支持两种形式的链接语法： 行内式和参考式两种形式，链接文字都是用 [方括号] 来标记。</p><h3 id="行内式链接："><a href="#行内式链接：" class="headerlink" title="行内式链接："></a>行内式链接：</h3><pre><code>This is [an example](http://example.com/ &quot;Title&quot;) inline link.[This link](http://example.net/) has no title attribute.</code></pre><h3 id="参考式链接："><a href="#参考式链接：" class="headerlink" title="参考式链接："></a>参考式链接：</h3><p>先标记</p><pre><code>This is [an example][id] reference-style link.</code></pre><p>然后任意位置定义链接(下面几种意义相同)</p><pre><code>[id]: http://example.com/  &quot;Optional Title Here&quot;[id]: http://example.com/  &apos;Optional Title Here&apos;[id]: http://example.com/  (Optional Title Here)[id]: &lt;http://example.com/&gt;  &quot;Optional Title Here&quot;</code></pre><h3 id="隐式链接："><a href="#隐式链接：" class="headerlink" title="隐式链接："></a>隐式链接：</h3><p>链接标记会视为等同于链接文字，要用隐式链接标记只要在链接文字后面加上一个空的方括号<br>比如想要让 “Google” 链接到 google.com，可以定义为</p><pre><code>[Google][]</code></pre><p>然后再定义链接内容</p><pre><code>[Google]: http://google.com/    </code></pre><h3 id="图片链接："><a href="#图片链接：" class="headerlink" title="图片链接："></a>图片链接：</h3><pre><code>[![95xPJS.md.jpg](https://s1.ax1x.com/2018/03/17/95xPJS.md.jpg)](https://imgchr.com/i/95xPJS)</code></pre><p>效果为<br><a href="https://imgchr.com/i/95xPJS" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2018/03/17/95xPJS.md.jpg" alt="95xPJS.md.jpg"></a></p><h3 id="自动链接："><a href="#自动链接：" class="headerlink" title="自动链接："></a>自动链接：</h3><p>Markdown 支持以比较简短的自动链接形式来处理网址和电子邮件信箱，只要是用方括号包起来， Markdown 就会自动把它转成链接。一般网址的链接文字就和链接地址一样，例如：</p><pre><code>&lt;http://example.com/&gt;</code></pre><p>会转为</p><pre><code>&lt;a href=&quot;http://example.com/&quot;&gt;http://example.com/&lt;/a&gt;</code></pre><h2 id="反斜杠"><a href="#反斜杠" class="headerlink" title="反斜杠"></a>反斜杠</h2><p>Markdown 可以利用反斜杠来插入一些在语法中有其它意义的符号，例如：如果你想要用星号加在文字旁边的方式来做出强调效果（但不用 &lt; em &gt; 标签），你可以在星号的前面加上反斜杠：</p><pre><code>\*lemon\*</code></pre><p>Markdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号：</p><pre><code>\   反斜线`   反引号*   星号_   底线{}  花括号[]  方括号()  括弧#   井字号+   加号-   减号.   英文句点!   惊叹号</code></pre><hr><p>参考学习 <a href="https://www.appinn.com/markdown/index.html" target="_blank" rel="noopener">Markdown 语法说明 (简体中文版)</a>  并整理</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Markdown&quot;&gt;&lt;a href=&quot;#Markdown&quot; class=&quot;headerlink&quot; title=&quot;Markdown&quot;&gt;&lt;/a&gt;Markdown&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯
      
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="知识点" scheme="http://yoursite.com/tags/%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    
      <category term="Markdown" scheme="http://yoursite.com/tags/Markdown/"/>
    
  </entry>
  
</feed>
