<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>咫尺天涯</title>
  
  <subtitle>是谁说过：时间仍在，是我们在飞逝</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-04-17T07:15:52.225Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Jellyleo</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java设计模式(二)</title>
    <link href="http://yoursite.com/2018/04/10/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F(%E4%BA%8C)/"/>
    <id>http://yoursite.com/2018/04/10/Java设计模式(二)/</id>
    <published>2018-04-10T11:33:19.000Z</published>
    <updated>2018-04-17T07:15:52.225Z</updated>
    
    <content type="html"><![CDATA[<h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>工厂模式是一种创建型模式，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。<br><strong>优点</strong>： 1、一个调用者想创建一个对象，只要知道其名称就可以了。 2、扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。 3、屏蔽产品的具体实现，调用者只关心产品的接口。<br><strong>缺点</strong>：每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖，不便于维护。<br><strong>应用实例</strong>：1、您需要一辆汽车，可以直接从工厂里面提货，而不用去管这辆汽车是怎么做出来的，以及这个汽车里面的具体实现。 2、Hibernate 换数据库只需换方言和驱动就可以。<br><strong>使用场景</strong>： 1、日志记录器：记录可能记录到本地硬盘、系统事件、远程服务器等，用户可以选择记录日志到什么地方。 2、数据库访问，当用户不知道最后系统采用哪一类数据库，以及数据库可能有变化时。 3、设计一个连接服务器的框架，需要三个协议，”POP3”、”IMAP”、”HTTP”，可以把这三个作为产品类，共同实现一个接口。<br><strong>注意事项</strong>：作为一种创建类模式，在任何需要生成复杂对象的地方，都可以使用工厂方法模式。有一点需要注意的地方就是复杂对象适合使用工厂模式，而简单对象，特别是只需要通过 new 就可以完成创建的对象，无需使用工厂模式。如果使用工厂模式，就需要引入一个工厂类，会增加系统的复杂度。</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>先创建Shape接口和Shape接口的实现类，然后再定义ShapeFactory</p><h4 id="步骤-1-创建接口"><a href="#步骤-1-创建接口" class="headerlink" title="步骤 1 创建接口"></a><strong>步骤 1 创建接口</strong></h4><p>shape.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface Shape &#123;</span><br><span class="line">   void draw();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="步骤-2-创建接口的实现类"><a href="#步骤-2-创建接口的实现类" class="headerlink" title="步骤 2 创建接口的实现类"></a><strong>步骤 2 创建接口的实现类</strong></h4><p>Rectangle.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Rectangle implements Shape &#123;</span><br><span class="line"></span><br><span class="line">   @Override</span><br><span class="line">   public void draw() &#123;</span><br><span class="line">      System.out.println(&quot;Inside Rectangle::draw() method.&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Square.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Square implements Shape &#123;</span><br><span class="line"></span><br><span class="line">   @Override</span><br><span class="line">   public void draw() &#123;</span><br><span class="line">      System.out.println(&quot;Inside Square::draw() method.&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Circle.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Circle implements Shape &#123;</span><br><span class="line"></span><br><span class="line">   @Override</span><br><span class="line">   public void draw() &#123;</span><br><span class="line">      System.out.println(&quot;Inside Circle::draw() method.&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="步骤-3-创建一个工厂，生成基于给定信息的实体类的对象"><a href="#步骤-3-创建一个工厂，生成基于给定信息的实体类的对象" class="headerlink" title="步骤 3 创建一个工厂，生成基于给定信息的实体类的对象"></a><strong>步骤 3 创建一个工厂，生成基于给定信息的实体类的对象</strong></h4><p>ShapeFactory.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class ShapeFactory &#123;</span><br><span class="line">    </span><br><span class="line">   //使用 getShape 方法获取形状类型的对象</span><br><span class="line">   public Shape getShape(String shapeType)&#123;</span><br><span class="line">      if(shapeType == null)&#123;</span><br><span class="line">         return null;</span><br><span class="line">      &#125;        </span><br><span class="line">      if(shapeType.equalsIgnoreCase(&quot;CIRCLE&quot;))&#123;</span><br><span class="line">         return new Circle();</span><br><span class="line">      &#125; else if(shapeType.equalsIgnoreCase(&quot;RECTANGLE&quot;))&#123;</span><br><span class="line">         return new Rectangle();</span><br><span class="line">      &#125; else if(shapeType.equalsIgnoreCase(&quot;SQUARE&quot;))&#123;</span><br><span class="line">         return new Square();</span><br><span class="line">      &#125;</span><br><span class="line">      return null;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="步骤-4-使用该工厂，通过传递类型信息来获取实体类的对象"><a href="#步骤-4-使用该工厂，通过传递类型信息来获取实体类的对象" class="headerlink" title="步骤 4 使用该工厂，通过传递类型信息来获取实体类的对象"></a><strong>步骤 4 使用该工厂，通过传递类型信息来获取实体类的对象</strong></h4><p>FactoryPatternDemo.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class FactoryPatternDemo &#123;</span><br><span class="line"></span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">      ShapeFactory shapeFactory = new ShapeFactory();</span><br><span class="line"></span><br><span class="line">      //获取 Circle 的对象，并调用它的 draw 方法</span><br><span class="line">      Shape shape1 = shapeFactory.getShape(&quot;CIRCLE&quot;);</span><br><span class="line"></span><br><span class="line">      //调用 Circle 的 draw 方法</span><br><span class="line">      shape1.draw();</span><br><span class="line"></span><br><span class="line">      //获取 Rectangle 的对象，并调用它的 draw 方法</span><br><span class="line">      Shape shape2 = shapeFactory.getShape(&quot;RECTANGLE&quot;);</span><br><span class="line"></span><br><span class="line">      //调用 Rectangle 的 draw 方法</span><br><span class="line">      shape2.draw();</span><br><span class="line"></span><br><span class="line">      //获取 Square 的对象，并调用它的 draw 方法</span><br><span class="line">      Shape shape3 = shapeFactory.getShape(&quot;SQUARE&quot;);</span><br><span class="line"></span><br><span class="line">      //调用 Square 的 draw 方法</span><br><span class="line">      shape3.draw();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h2><h3 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h3><p>抽象工厂模式是围绕一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。在抽象工厂模式中，接口是负责创建一个相关对象的工厂，不需要显式指定它们的类。每个生成的工厂都能按照工厂模式提供对象。<br><strong>优点</strong>：当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象。<br><strong>缺点</strong>：产品族扩展非常困难，要增加一个系列的某一产品，既要在抽象的 Creator 里加代码，又要在具体的里面加代码。<br><strong>应用实例</strong>：一个人会有多套衣服，休闲装 、商务装、运动装等，这些衣服都是成套存在的，即是一系列的具体产品。假设在家里有多个衣柜，某一个衣柜只存放一种成套衣服，每次要拿这种成套的衣服也自然是在这个衣柜中取出。用oo的思想去理解，所有的衣柜（具体工厂）都是衣柜类（抽象工厂）的某一个，而每件成套的衣服又包括具体的上衣、裤子（某一具体产品），这些具体的上衣都是上衣（抽象产品），具体的裤子也是裤子（抽象产品）。<br><strong>使用场景</strong>： 1、QQ 换皮肤，一整套一起换。 2、生成不同操作系统的程序。<br><strong>注意事项</strong>：产品族难扩展，产品等级易扩展。</p><h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><p>先创建 Shape 和 Color 接口和实现这些接口的实体类；然后创建抽象工厂类 AbstractFactory；接着定义工厂类 ShapeFactory 和 ColorFactory，这两个工厂类都是扩展了 AbstractFactory；最后创建一个工厂创造器/生成器类 FactoryProducer。</p><h4 id="步骤-1-为形状创建一个接口"><a href="#步骤-1-为形状创建一个接口" class="headerlink" title="步骤 1 为形状创建一个接口"></a><strong>步骤 1 为形状创建一个接口</strong></h4><p>Shape.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface Shape &#123;</span><br><span class="line">   void draw();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="步骤-2-创建实现接口的实体类"><a href="#步骤-2-创建实现接口的实体类" class="headerlink" title="步骤 2 创建实现接口的实体类"></a><strong>步骤 2 创建实现接口的实体类</strong></h4><p>Rectangle.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Rectangle implements Shape &#123;</span><br><span class="line"></span><br><span class="line">   @Override</span><br><span class="line">   public void draw() &#123;</span><br><span class="line">      System.out.println(&quot;Inside Rectangle::draw() method.&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Square.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Square implements Shape &#123;</span><br><span class="line"></span><br><span class="line">   @Override</span><br><span class="line">   public void draw() &#123;</span><br><span class="line">      System.out.println(&quot;Inside Square::draw() method.&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Circle.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Circle implements Shape &#123;</span><br><span class="line"></span><br><span class="line">   @Override</span><br><span class="line">   public void draw() &#123;</span><br><span class="line">      System.out.println(&quot;Inside Circle::draw() method.&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="步骤-3-为颜色创建一个接口"><a href="#步骤-3-为颜色创建一个接口" class="headerlink" title="步骤 3 为颜色创建一个接口"></a><strong>步骤 3 为颜色创建一个接口</strong></h4><p>Color.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface Color &#123;</span><br><span class="line">   void fill();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="步骤-4-创建实现接口的实体类"><a href="#步骤-4-创建实现接口的实体类" class="headerlink" title="步骤 4 创建实现接口的实体类"></a><strong>步骤 4 创建实现接口的实体类</strong></h4><p>Red.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Red implements Color &#123;</span><br><span class="line"></span><br><span class="line">   @Override</span><br><span class="line">   public void fill() &#123;</span><br><span class="line">      System.out.println(&quot;Inside Red::fill() method.&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Green.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Green implements Color &#123;</span><br><span class="line"></span><br><span class="line">   @Override</span><br><span class="line">   public void fill() &#123;</span><br><span class="line">      System.out.println(&quot;Inside Green::fill() method.&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Blue.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Blue implements Color &#123;</span><br><span class="line"></span><br><span class="line">   @Override</span><br><span class="line">   public void fill() &#123;</span><br><span class="line">      System.out.println(&quot;Inside Blue::fill() method.&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="步骤-5-为-Color-和-Shape-对象创建抽象类来获取工厂"><a href="#步骤-5-为-Color-和-Shape-对象创建抽象类来获取工厂" class="headerlink" title="步骤 5 为 Color 和 Shape 对象创建抽象类来获取工厂"></a><strong>步骤 5 为 Color 和 Shape 对象创建抽象类来获取工厂</strong></h4><p>AbstractFactory.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public abstract class AbstractFactory &#123;</span><br><span class="line">   abstract Color getColor(String color);</span><br><span class="line">   abstract Shape getShape(String shape) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="步骤-6-创建扩展了-AbstractFactory-的工厂类，基于给定的信息生成实体类的对象"><a href="#步骤-6-创建扩展了-AbstractFactory-的工厂类，基于给定的信息生成实体类的对象" class="headerlink" title="步骤 6 创建扩展了 AbstractFactory 的工厂类，基于给定的信息生成实体类的对象"></a><strong>步骤 6 创建扩展了 AbstractFactory 的工厂类，基于给定的信息生成实体类的对象</strong></h4><p>ShapeFactory.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class ShapeFactory extends AbstractFactory &#123;</span><br><span class="line">    </span><br><span class="line">   @Override</span><br><span class="line">   public Shape getShape(String shapeType)&#123;</span><br><span class="line">      if(shapeType == null)&#123;</span><br><span class="line">         return null;</span><br><span class="line">      &#125;        </span><br><span class="line">      if(shapeType.equalsIgnoreCase(&quot;CIRCLE&quot;))&#123;</span><br><span class="line">         return new Circle();</span><br><span class="line">      &#125; else if(shapeType.equalsIgnoreCase(&quot;RECTANGLE&quot;))&#123;</span><br><span class="line">         return new Rectangle();</span><br><span class="line">      &#125; else if(shapeType.equalsIgnoreCase(&quot;SQUARE&quot;))&#123;</span><br><span class="line">         return new Square();</span><br><span class="line">      &#125;</span><br><span class="line">      return null;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   @Override</span><br><span class="line">   Color getColor(String color) &#123;</span><br><span class="line">      return null;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>ColorFactory.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class ColorFactory extends AbstractFactory &#123;</span><br><span class="line">    </span><br><span class="line">   @Override</span><br><span class="line">   public Shape getShape(String shapeType)&#123;</span><br><span class="line">      return null;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   @Override</span><br><span class="line">   Color getColor(String color) &#123;</span><br><span class="line">      if(color == null)&#123;</span><br><span class="line">         return null;</span><br><span class="line">      &#125;        </span><br><span class="line">      if(color.equalsIgnoreCase(&quot;RED&quot;))&#123;</span><br><span class="line">         return new Red();</span><br><span class="line">      &#125; else if(color.equalsIgnoreCase(&quot;GREEN&quot;))&#123;</span><br><span class="line">         return new Green();</span><br><span class="line">      &#125; else if(color.equalsIgnoreCase(&quot;BLUE&quot;))&#123;</span><br><span class="line">         return new Blue();</span><br><span class="line">      &#125;</span><br><span class="line">      return null;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="步骤-7-创建一个工厂创造器-生成器类，通过传递形状或颜色信息来获取工厂"><a href="#步骤-7-创建一个工厂创造器-生成器类，通过传递形状或颜色信息来获取工厂" class="headerlink" title="步骤 7 创建一个工厂创造器/生成器类，通过传递形状或颜色信息来获取工厂"></a><strong>步骤 7 创建一个工厂创造器/生成器类，通过传递形状或颜色信息来获取工厂</strong></h4><p>FactoryProducer.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class FactoryProducer &#123;</span><br><span class="line">   public static AbstractFactory getFactory(String choice)&#123;</span><br><span class="line">      if(choice.equalsIgnoreCase(&quot;SHAPE&quot;))&#123;</span><br><span class="line">         return new ShapeFactory();</span><br><span class="line">      &#125; else if(choice.equalsIgnoreCase(&quot;COLOR&quot;))&#123;</span><br><span class="line">         return new ColorFactory();</span><br><span class="line">      &#125;</span><br><span class="line">      return null;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="步骤-8-使用-FactoryProducer-来获取-AbstractFactory，通过传递类型信息来获取实体类的对象"><a href="#步骤-8-使用-FactoryProducer-来获取-AbstractFactory，通过传递类型信息来获取实体类的对象" class="headerlink" title="步骤 8 使用 FactoryProducer 来获取 AbstractFactory，通过传递类型信息来获取实体类的对象"></a><strong>步骤 8 使用 FactoryProducer 来获取 AbstractFactory，通过传递类型信息来获取实体类的对象</strong></h4><p>AbstractFactoryPatternDemo.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">public class AbstractFactoryPatternDemo &#123;</span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">      //获取形状工厂</span><br><span class="line">      AbstractFactory shapeFactory = FactoryProducer.getFactory(&quot;SHAPE&quot;);</span><br><span class="line"></span><br><span class="line">      //获取形状为 Circle 的对象</span><br><span class="line">      Shape shape1 = shapeFactory.getShape(&quot;CIRCLE&quot;);</span><br><span class="line"></span><br><span class="line">      //调用 Circle 的 draw 方法</span><br><span class="line">      shape1.draw();</span><br><span class="line"></span><br><span class="line">      //获取形状为 Rectangle 的对象</span><br><span class="line">      Shape shape2 = shapeFactory.getShape(&quot;RECTANGLE&quot;);</span><br><span class="line"></span><br><span class="line">      //调用 Rectangle 的 draw 方法</span><br><span class="line">      shape2.draw();</span><br><span class="line">      </span><br><span class="line">      //获取形状为 Square 的对象</span><br><span class="line">      Shape shape3 = shapeFactory.getShape(&quot;SQUARE&quot;);</span><br><span class="line"></span><br><span class="line">      //调用 Square 的 draw 方法</span><br><span class="line">      shape3.draw();</span><br><span class="line"></span><br><span class="line">      //获取颜色工厂</span><br><span class="line">      AbstractFactory colorFactory = FactoryProducer.getFactory(&quot;COLOR&quot;);</span><br><span class="line"></span><br><span class="line">      //获取颜色为 Red 的对象</span><br><span class="line">      Color color1 = colorFactory.getColor(&quot;RED&quot;);</span><br><span class="line"></span><br><span class="line">      //调用 Red 的 fill 方法</span><br><span class="line">      color1.fill();</span><br><span class="line"></span><br><span class="line">      //获取颜色为 Green 的对象</span><br><span class="line">      Color color2 = colorFactory.getColor(&quot;Green&quot;);</span><br><span class="line"></span><br><span class="line">      //调用 Green 的 fill 方法</span><br><span class="line">      color2.fill();</span><br><span class="line"></span><br><span class="line">      //获取颜色为 Blue 的对象</span><br><span class="line">      Color color3 = colorFactory.getColor(&quot;BLUE&quot;);</span><br><span class="line"></span><br><span class="line">      //调用 Blue 的 fill 方法</span><br><span class="line">      color3.fill();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;工厂模式&quot;&gt;&lt;a href=&quot;#工厂模式&quot; class=&quot;headerlink&quot; title=&quot;工厂模式&quot;&gt;&lt;/a&gt;工厂模式&lt;/h2&gt;&lt;h3 id=&quot;描述&quot;&gt;&lt;a href=&quot;#描述&quot; class=&quot;headerlink&quot; title=&quot;描述&quot;&gt;&lt;/a&gt;描述&lt;/h
      
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="知识点" scheme="http://yoursite.com/tags/%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    
  </entry>
  
  <entry>
    <title>Java设计模式(一)</title>
    <link href="http://yoursite.com/2018/04/09/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F(%E4%B8%80)/"/>
    <id>http://yoursite.com/2018/04/09/Java设计模式(一)/</id>
    <published>2018-04-09T10:15:41.000Z</published>
    <updated>2018-04-10T10:25:30.637Z</updated>
    
    <content type="html"><![CDATA[<h1 id="设计模式简介"><a href="#设计模式简介" class="headerlink" title="设计模式简介"></a>设计模式简介</h1><blockquote><p>设计模式是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了重用代码、让代码更容易被他人理解、保证代码可靠性。 毫无疑问，设计模式于己于他人于系统都是多赢的，设计模式使代码编制真正工程化，设计模式是软件工程的基石，如同大厦的一块块砖石一样。项目中合理地运用设计模式可以完美地解决很多问题，每种模式在现实中都有相应的原理来与之对应，每种模式都描述了一个在我们周围不断重复发生的问题，以及该问题的核心解决方案，这也是设计模式能被广泛应用的原因。</p></blockquote><h1 id="设计模式分类"><a href="#设计模式分类" class="headerlink" title="设计模式分类"></a>设计模式分类</h1><p>设计模式统共有23种，这23种又分为三大类：创建型模式（Creational Patterns）、结构型模式（Structural Patterns）、行为型模式（Behavioral Patterns），此外，还有J2EE设计模式。</p><table><thead><tr><th style="text-align:left">模式&amp;简述</th><th style="text-align:left">包括</th></tr></thead><tbody><tr><td style="text-align:left"><strong>创建型模式</strong><br>创建对象同时隐藏创建逻辑，而不是使用 new 运算符直接实例化对象，在判断具体实例需要创建哪些对象时更加灵活</td><td style="text-align:left">工厂模式（Factory Pattern）<br>抽象工厂模式（Abstract Factory Pattern）<br>单例模式（Singleton Pattern）<br>建造者模式（Builder Pattern）<br>原型模式（Prototype Pattern）</td></tr><tr><td style="text-align:left"><strong>结构型模式</strong><br>这些设计模式关注类和对象的组合，继承的概念被用来组合接口和定义组合对象获得新功能的方式。</td><td style="text-align:left">适配器模式（Adapter Pattern）<br>桥接模式（Bridge Pattern）<br>过滤器模式（Filter、Criteria Pattern）<br>组合模式（Composite Pattern）<br>装饰器模式（Decorator Pattern）<br>外观模式（Facade Pattern）<br>享元模式（Flyweight Pattern）<br>代理模式（Proxy Pattern）</td></tr><tr><td style="text-align:left"><strong>行为型模式</strong><br>这些模式特别关注对象之间的通信。</td><td style="text-align:left">责任链模式（Chain of Responsibility Pattern）<br>命令模式（Command Pattern）<br>解释器模式（Interpreter Pattern）<br>迭代器模式（Iterator Pattern）<br>中介者模式（Mediator Pattern）<br>备忘录模式（Memento Pattern）<br>观察者模式（Observer Pattern）<br>状态模式（State Pattern）<br>空对象模式（Null Object Pattern）<br>策略模式（Strategy Pattern）<br>模板模式（Template Pattern）<br>访问者模式（Visitor Pattern）</td></tr><tr><td style="text-align:left"><strong>J2EE模式</strong><br>这些设计模式特别关注表示层。</td><td style="text-align:left">MVC 模式（MVC Pattern）<br>业务代表模式（Business Delegate Pattern）<br>组合实体模式（Composite Entity Pattern）<br>数据访问对象模式（Data Access Object Pattern）<br>前端控制器模式（Front Controller Pattern）<br>拦截过滤器模式（Intercepting Filter Pattern）<br> 服务定位器模式（Service Locator Pattern）<br>传输对象模式（Transfer Object Pattern）</td></tr></tbody></table><p>设计模式关系图：<br><img src="https://s1.ax1x.com/2018/04/10/CF4FyR.jpg" alt="关系图"></p><h1 id="设计模式六大原则"><a href="#设计模式六大原则" class="headerlink" title="设计模式六大原则"></a>设计模式六大原则</h1><h3 id="1、开闭原则（Open-Close-Principle）"><a href="#1、开闭原则（Open-Close-Principle）" class="headerlink" title="1、开闭原则（Open Close Principle）"></a>1、开闭原则（Open Close Principle）</h3><p>开闭原则的意思是：对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类。</p><h3 id="2、里氏代换原则（Liskov-Substitution-Principle）"><a href="#2、里氏代换原则（Liskov-Substitution-Principle）" class="headerlink" title="2、里氏代换原则（Liskov Substitution Principle）"></a>2、里氏代换原则（Liskov Substitution Principle）</h3><p>里氏代换原则是面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。LSP 是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为。里氏代换原则是对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。</p><h3 id="3、依赖倒转原则（Dependence-Inversion-Principle）"><a href="#3、依赖倒转原则（Dependence-Inversion-Principle）" class="headerlink" title="3、依赖倒转原则（Dependence Inversion Principle）"></a>3、依赖倒转原则（Dependence Inversion Principle）</h3><p>个原则是开闭原则的基础，具体内容：针对接口编程，依赖于抽象而不依赖于具体。</p><h3 id="4、接口隔离原则（Interface-Segregation-Principle）"><a href="#4、接口隔离原则（Interface-Segregation-Principle）" class="headerlink" title="4、接口隔离原则（Interface Segregation Principle）"></a>4、接口隔离原则（Interface Segregation Principle）</h3><p>这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。它还有另外一个意思是：降低类之间的耦合度。由此可见，其实设计模式就是从大型软件架构出发、便于升级和维护的软件设计思想，它强调降低依赖，降低耦合。</p><h3 id="5、迪米特法则（Demeter-Principle）"><a href="#5、迪米特法则（Demeter-Principle）" class="headerlink" title="5、迪米特法则（Demeter Principle）"></a>5、迪米特法则（Demeter Principle）</h3><p>迪米特法则是指：一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。</p><h3 id="6、合成复用原则（Composite-Reuse-Principle）"><a href="#6、合成复用原则（Composite-Reuse-Principle）" class="headerlink" title="6、合成复用原则（Composite Reuse Principle）"></a>6、合成复用原则（Composite Reuse Principle）</h3><h2 id="合成复用原则是指：尽量使用合成-聚合的方式，而不是使用继承。"><a href="#合成复用原则是指：尽量使用合成-聚合的方式，而不是使用继承。" class="headerlink" title="合成复用原则是指：尽量使用合成/聚合的方式，而不是使用继承。"></a>合成复用原则是指：尽量使用合成/聚合的方式，而不是使用继承。</h2><p>原文 <a href="http://www.runoob.com/design-pattern/design-pattern-tutorial.html" target="_blank" rel="noopener">菜鸟教程</a>参考整理</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;设计模式简介&quot;&gt;&lt;a href=&quot;#设计模式简介&quot; class=&quot;headerlink&quot; title=&quot;设计模式简介&quot;&gt;&lt;/a&gt;设计模式简介&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;设计模式是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结。使用
      
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="知识点" scheme="http://yoursite.com/tags/%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    
  </entry>
  
  <entry>
    <title>我听说</title>
    <link href="http://yoursite.com/2018/03/17/%E6%88%91%E5%90%AC%E8%AF%B4/"/>
    <id>http://yoursite.com/2018/03/17/我听说/</id>
    <published>2018-03-16T21:52:51.965Z</published>
    <updated>2018-03-16T21:58:07.803Z</updated>
    
    <content type="html"><![CDATA[<p>　　我听说，有一种猫叫做雨猫。天气温暖时，它就变得蓬松毛绒绒的，像白云一样上浮，你可以拴着它，像放风筝一样走，它会变透明，阳光透得过它的身体。天气晦暗时它会变黑，坠在地上，满地乱跑，毛变得硬硬的，像刚刮过的胡茬一样。你得抱着它，等天气晴朗时，再把它放出去，就像风筝末梢放着一团棉花糖。</p><p>　　我听说，有种青蛙，透明洁白，只吃茶叶。吃多之后，吐气如兰。冬天它便僵卧，张着大嘴，眠去一个季节。你往它肚里倒热水，水便成茶，馥郁芳香，可以倒在杯子里喝，香沁肺腑。有个女孩子，手头没有杯子，于是捧起青蛙，嘴对着嘴，把青蛙嘴当茶杯口。结果青蛙醒了，变成一白衣少年：“哪个公主吻了我？”</p><p>　　我听说，有一种驯鹿，很爱长颈鹿的斑纹和气味，但是太矮，又碍于长颈鹿是哑巴，所以没法谈恋爱。于是它们就长起了杉树一样直拔云天的角，然后到处找一个人，在角的顶端造一个房子住着。每天，那个人负责在高树摘果子，送给长颈鹿吃，以促成驯鹿和长颈鹿的爱情——虽然见不到面，但灵魂相通的爱情。</p><p>　　我听说，北方有一种松鼠，特别大，毛茸茸的，睡觉时喜欢摊开四肢，露出软绵绵的肚皮。你抓住一只，混熟了，就可以把它当床，睡在它的肚子上，用它的尾巴做被子。但它喜欢梦游，到处爬，所以你睡着前眼睛明明看见天花板的花纹，醒来时就可能看见松树枝、杉树枝、云、麻雀和松毛虫。</p><p>　　我听说，有一种猫，特别怕冷，一遇到冷环境就全身长起蓬松松软绵绵的长毛，并且开始冬眠，怎么叫都不醒。冬天你把它挂在脖子上出门，就好像穿了件毛大衣。到了温暖的室内，它暖醒了，就喵一声跳下来，自己到炉子旁边去接着睡了。因为冬天很长，它在冬天基本是裘状，所以叫冬裘夏猫。</p><p>　　我听说，有种野猪，睡一觉就长一层脂肪，起来跑一跑就练出一层肌肉，所以他身上肥瘦肥瘦，像夹心饼干。他爱去南方的海边泡澡，泡一身大粒子盐味，吹风，然后哼唧哼唧去温泉，一边蒸自己一边吃树叶子。你埋伏在温泉边，射倒它，能吃到现成的蒸火腿。你最好带蜂蜜，敷一遍再蒸，更好吃。</p><p>　　我听说，以前有人喜欢在海蚌上写故事写诗。你走在海边，海蚌会跟你说：我身上有字，可以给你看噢，但有个条件，我不识字，你得念给我听。你答应了，海蚌就张开壳来，让你给它念故事。如果你看入神忘了继续念，或者企图摘抄剽窃，海蚌就会夹你一下；如果你念得好，海蚌就送你颗珍珠。</p><p>　　我听说，南方有一种鸟，身材纤瘦，尾羽很长，善吟诗，平时看上去盈盈一握，却筋骨健壮。如果你和它混熟了，它就会把身体绷直，你可以握着它的腰，用它的嘴蘸墨、写字，画梅花、打印章时，还可以用它印个浅爪痕。可是它挑剔得很，墨质差，纸脏，字写得难看，或者句子毫无文采，它就会破口大骂：“居然用老娘写这么烂的文章！”</p><p>我听说有种雪狐，极妩媚，皮毛柔滑。善学声音，爱恶作剧，喜在窗外学男主人女同学、女同事等声音，引女主人疑心吵架，引以为乐。被抓住后会要求：给你雪狐裘，放我走吧。若男主人不允，她便媚笑：原来是你舍不得我走啊嗯……女主人遂朝男主人双目圆睁：你留她干嘛，还不放走？心思又活络了嗯？！</p><p>　　我听说，有种熊叫做云熊，其白如雪，其大若垂天之云。春天开始浮游，夏天吸取阳光。冬天，它随风在天空飘荡，到一个寒冷的地方，就开始下一团团的熊绒毛。熊绒可做大衣，闻得到夏天阳光的味道。熊绒落完，它也就飘下地来。你闻以蜂蜜，冬眠。到春天它长起了毛，就又变成云浮起来了。</p><p>　　我听说有种蜗牛，寿命很长，以八千岁为春，以八千岁为秋。丈夫对妻子说，我要吻你一下，然后出门去买报纸。妻子就闭上眼，等了八天，吻到了，于是丈夫出门了。等他回来，妻子抱怨说：你这一走就是六百年，我好担心。丈夫说：哎呀，我是怕又过时了，站在那里花二百年把新闻看了嘛。</p><p>　　我听说有种章鱼，善于下厨。你坐柜台后面，问它要三明治寿司刺身铁板烧咖啡茶涮锅烤串回锅肉，它舞起手臂们，切剔炒烹翻炸调撒料颠勺，又快又好，还能剩出三只手，一只负责收钱，两只和你打扑克解闷。但它开不起玩笑，偶尔它不小心手臂被铁板烫到，你可不能说“那我要这条章鱼烧！” 不然它就会舞起锅铲，任你是三头六臂也挡不住它四面八方朝你扔鱼丸。</p><p>　　我听说有种虎鲸，很温柔，喜欢光，不潜游，但又怕晒。你在它背上铺沙子，张阳伞，它便喜欢你，任你在它背上住下，钓鱼、睡午觉、接吻、喝果汁。每天它张嘴吞许多小鱼，自己吃些，剩下的喷水送给你，于是你天天有新鲜刺身吃。偶然它也馋，愿意吃熟的，就会张嘴，要你抛给吃章鱼烧。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;　　我听说，有一种猫叫做雨猫。天气温暖时，它就变得蓬松毛绒绒的，像白云一样上浮，你可以拴着它，像放风筝一样走，它会变透明，阳光透得过它的身体。天气晦暗时它会变黑，坠在地上，满地乱跑，毛变得硬硬的，像刚刮过的胡茬一样。你得抱着它，等天气晴朗时，再把它放出去，就像风筝末梢放着一
      
    
    </summary>
    
      <category term="美文" scheme="http://yoursite.com/categories/%E7%BE%8E%E6%96%87/"/>
    
    
      <category term="随笔" scheme="http://yoursite.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="摘抄" scheme="http://yoursite.com/tags/%E6%91%98%E6%8A%84/"/>
    
  </entry>
  
  <entry>
    <title>Markdown 常用语法(一)</title>
    <link href="http://yoursite.com/2018/03/16/markdown%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95(%E4%B8%80)/"/>
    <id>http://yoursite.com/2018/03/16/markdown常用语法(一)/</id>
    <published>2018-03-15T18:56:30.915Z</published>
    <updated>2018-04-10T10:00:28.114Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Markdown"><a href="#Markdown" class="headerlink" title="Markdown"></a>Markdown</h2><blockquote><p>Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档，然后转换成格式丰富的HTML页面。    —— <a href="https://zh.wikipedia.org/wiki/Markdown" target="_blank"> [ 维基百科 ]</a></p></blockquote><h2 id="修辞和强调"><a href="#修辞和强调" class="headerlink" title="修辞和强调"></a>修辞和强调</h2><p>Markdown 使用星号和底线来标记需要强调的区段。<br>Some of these words <em>are emphasized</em>.<br>Some of these words <em>are emphasized also</em>.<br>Use two asterisks for <strong>strong emphasis</strong>.<br>Or, if you prefer, <strong>use two underscores instead</strong>.</p><h2 id="列表和表格"><a href="#列表和表格" class="headerlink" title="列表和表格"></a>列表和表格</h2><p>无序列表使用星号、加号和减号来做为列表的项目标记，这些符号是都可以使用的，使用<br>星号：</p><pre><code>* Candy.* Gum.* Booze.</code></pre><p>加号：</p><pre><code>+ Candy.+ Gum.+ Booze.</code></pre><p>减号：</p><pre><code>- Candy.- Gum.- Booze.</code></pre><p>全部都显示为：</p><pre><code>&lt;ul&gt;&lt;li&gt;Candy.&lt;/li&gt;&lt;li&gt;Gum.&lt;/li&gt;&lt;li&gt;Booze.&lt;/li&gt;&lt;/ul&gt;</code></pre><p>有序的列表则是使用一般的数字接着一个英文句点作为项目标记：</p><pre><code>1. Red2. Green3. Blue</code></pre><p>显示为：</p><pre><code>&lt;ol&gt;&lt;li&gt;Red&lt;/li&gt;&lt;li&gt;Green&lt;/li&gt;&lt;li&gt;Blue&lt;/li&gt;&lt;/ol&gt;</code></pre><p>可以使用冒号来定义表格对齐方式：</p><pre><code>| 项目      |    价格 | 数量  || :-------- | --------:| :--: || Computer  | 1600 元 |  5   || Phone     |   12 元 |  12  || Pipe      |    1 元 | 234  |</code></pre><p>显示为</p><table><thead><tr><th style="text-align:left">项目</th><th style="text-align:right">价格</th><th style="text-align:center">数量</th></tr></thead><tbody><tr><td style="text-align:left">Computer</td><td style="text-align:right">1600 元</td><td style="text-align:center">5</td></tr><tr><td style="text-align:left">Phone</td><td style="text-align:right">12 元</td><td style="text-align:center">12</td></tr><tr><td style="text-align:left">Pipe</td><td style="text-align:right">1 元</td><td style="text-align:center">234</td></tr></tbody></table><p><strong>Markdown　Extra</strong>　定义列表语法：</p><pre><code>项目１项目２:   定义 A:   定义 B项目３:   定义 C:   定义 D    &gt; 定义D内容</code></pre><p>显示为</p><blockquote><p>项目１<br>项目２<br>:   定义 A<br>:   定义 B</p><p>项目３<br>:   定义 C</p><p>:   定义 D</p><pre><code>&gt; 定义D内容</code></pre></blockquote><h2 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h2><p>代码块语法遵循标准markdown代码，用反引号包起来<br>例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">       <span class="comment">// TODO Auto-generated method stub  </span></span><br><span class="line">       File file = <span class="keyword">new</span> File(<span class="string">"F:\\Tomcat"</span>);  </span><br><span class="line">       list(file);  </span><br><span class="line">       Date myDate = <span class="keyword">new</span> Date();   </span><br><span class="line">       DateFormat df = DateFormat.getDateInstance();  </span><br><span class="line">       System.out.println(df.format(myDate));   </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><h2 id="链接和图片"><a href="#链接和图片" class="headerlink" title="链接和图片"></a>链接和图片</h2><p>Markdown 支持两种形式的链接语法： 行内式和参考式两种形式，链接文字都是用 [方括号] 来标记。</p><h3 id="行内式链接："><a href="#行内式链接：" class="headerlink" title="行内式链接："></a>行内式链接：</h3><pre><code>This is [an example](http://example.com/ &quot;Title&quot;) inline link.[This link](http://example.net/) has no title attribute.</code></pre><h3 id="参考式链接："><a href="#参考式链接：" class="headerlink" title="参考式链接："></a>参考式链接：</h3><p>先标记</p><pre><code>This is [an example][id] reference-style link.</code></pre><p>然后任意位置定义链接(下面几种意义相同)</p><pre><code>[id]: http://example.com/  &quot;Optional Title Here&quot;[id]: http://example.com/  &apos;Optional Title Here&apos;[id]: http://example.com/  (Optional Title Here)[id]: &lt;http://example.com/&gt;  &quot;Optional Title Here&quot;</code></pre><h3 id="隐式链接："><a href="#隐式链接：" class="headerlink" title="隐式链接："></a>隐式链接：</h3><p>链接标记会视为等同于链接文字，要用隐式链接标记只要在链接文字后面加上一个空的方括号<br>比如想要让 “Google” 链接到 google.com，可以定义为</p><pre><code>[Google][]</code></pre><p>然后再定义链接内容</p><pre><code>[Google]: http://google.com/    </code></pre><h3 id="图片链接："><a href="#图片链接：" class="headerlink" title="图片链接："></a>图片链接：</h3><pre><code>[![95xPJS.md.jpg](https://s1.ax1x.com/2018/03/17/95xPJS.md.jpg)](https://imgchr.com/i/95xPJS)</code></pre><p>效果为<br><a href="https://imgchr.com/i/95xPJS" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2018/03/17/95xPJS.md.jpg" alt="95xPJS.md.jpg"></a></p><h3 id="自动链接："><a href="#自动链接：" class="headerlink" title="自动链接："></a>自动链接：</h3><p>Markdown 支持以比较简短的自动链接形式来处理网址和电子邮件信箱，只要是用方括号包起来， Markdown 就会自动把它转成链接。一般网址的链接文字就和链接地址一样，例如：</p><pre><code>&lt;http://example.com/&gt;</code></pre><p>会转为</p><pre><code>&lt;a href=&quot;http://example.com/&quot;&gt;http://example.com/&lt;/a&gt;</code></pre><h2 id="反斜杠"><a href="#反斜杠" class="headerlink" title="反斜杠"></a>反斜杠</h2><p>Markdown 可以利用反斜杠来插入一些在语法中有其它意义的符号，例如：如果你想要用星号加在文字旁边的方式来做出强调效果（但不用 &lt; em &gt; 标签），你可以在星号的前面加上反斜杠：</p><pre><code>\*lemon\*</code></pre><p>Markdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号：</p><pre><code>\   反斜线`   反引号*   星号_   底线{}  花括号[]  方括号()  括弧#   井字号+   加号-   减号.   英文句点!   惊叹号</code></pre><hr><p>参考学习 <a href="https://www.appinn.com/markdown/index.html" target="_blank" rel="noopener">Markdown 语法说明 (简体中文版)</a>  并整理</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Markdown&quot;&gt;&lt;a href=&quot;#Markdown&quot; class=&quot;headerlink&quot; title=&quot;Markdown&quot;&gt;&lt;/a&gt;Markdown&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯
      
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="知识点" scheme="http://yoursite.com/tags/%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    
      <category term="Markdown" scheme="http://yoursite.com/tags/Markdown/"/>
    
  </entry>
  
</feed>
